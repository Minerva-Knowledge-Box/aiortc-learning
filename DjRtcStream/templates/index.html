<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Django aiortc — File Streaming</title>
    <style>
      body { font-family: system-ui, sans-serif; margin: 2rem; }
      video { width: 720px; max-width: 100%; background: #000; display:block; }
      button { padding:.6rem 1rem; margin-top:1rem; }
      .note { margin-top:.6rem; opacity:.75; }
      pre { background:#111; color:#eee; padding:8px; overflow:auto; max-height:220px;}
    </style>
  </head>
  <body>
    <h1>Stream file from server → browser (WebRTC)</h1>

    <video id="remote" autoplay playsinline controls muted></video>
    <div style="display:flex; gap:12px; align-items:center; margin-top:10px;">
      <button id="playBtn">Play</button>
      <button id="stopBtn">Stop</button>
    </div>
    <p class="note">
      Server streams <code>videos/sample.mp4</code> (or a test pattern if the file can't be decoded).
    </p>

    <pre id="log"></pre>

    <script>
      const btn = document.getElementById('playBtn');
      const stopBtn = document.getElementById('stopBtn');
      const remoteVideo = document.getElementById('remote');
      const logEl = document.getElementById('log');
      let pc;

      function log(...args) {
        const line = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
        console.log(line);
        logEl.textContent += line + "\n";
      }

      function waitForICEGatheringComplete(pc) {
        if (pc.iceGatheringState === 'complete') return Promise.resolve();
        return new Promise(resolve => {
          const check = () => {
            log('iceGatheringState:', pc.iceGatheringState);
            if (pc.iceGatheringState === 'complete') {
              pc.removeEventListener('icegatheringstatechange', check);
              resolve();
            }
          };
          pc.addEventListener('icegatheringstatechange', check);
        });
      }

      btn.addEventListener('click', async () => {
        btn.disabled = true;

        pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

        pc.oniceconnectionstatechange = () => log('ice state:', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('pc state:', pc.connectionState);

        // We only RECEIVE media
        pc.addTransceiver('video', { direction: 'recvonly' });
        pc.addTransceiver('audio', { direction: 'recvonly' });

        pc.ontrack = (e) => {
          log('ontrack kind=', e.track.kind);
          if (e.streams && e.streams[0]) {
            if (!remoteVideo.srcObject) remoteVideo.srcObject = e.streams[0];
          } else {
            const inbound = remoteVideo.srcObject || new MediaStream();
            inbound.addTrack(e.track);
            remoteVideo.srcObject = inbound;
          }
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForICEGatheringComplete(pc); // single-shot

        const resp = await fetch('/offer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type })
        });

        if (!resp.ok) {
          const txt = await resp.text();
          log('Server error:', txt);
          btn.disabled = false;
          return;
        }

        const answer = await resp.json();
        await pc.setRemoteDescription(answer);
        log('Answer set; waiting for ontrack…');
      });

      stopBtn.addEventListener('click', () => {
        if (pc) pc.close();
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject.getTracks().forEach(t => t.stop());
          remoteVideo.srcObject = null;
        }
        btn.disabled = false;
        log('Stopped.');
      });

      window.addEventListener('beforeunload', () => {
        if (pc) pc.close();
      });
    </script>
  </body>
</html>
